# 4장 클래스와 인터페이스

- 자바 언어에는 클래스와 인터페이스 설계에 사용하는 요소가 있다
- 이런 요소를 활용하여 클래스와 인터페이스를 **쓰기 편하고, 견고하며, 유연하게** 만드는 방법



## Item 15. 클래스와 멤버의 접근 권한을 최소화하라

- 잘 설계된 컴포넌트 : 클래스 내부 데이터와 **구현 정보**를 외부로 부터 **얼마나 잘 숨겼느냐**
  - 내부 구현을 숨겨, **구현과 API를 깔끔히 분리**
- 오직 **API를 통해서만 소통**



### 정보 은닉의 장점

- 개발 속도 상승. 시스템 병렬개발 가능
- 시스템 관리 비용 감소. 컴포넌트 디버깅
- 성능 최적화에 도움
- 재사용성 증진
- 큰 시스템 제작 난이도 감소



### Java의 정보 은닉 장치

- 접근 제한자
- 기본 원칙 : 모든 클래스와 멤버의 **접근성을 가능한 좁힌다**.

#### 1. 클래스 접근 제한자

- public : 공개 API
- package-private : **패키지 안에서만 사용**. 내부 구현되어 언제든 수정 가능. 클라이언트에 영향 없이 수정, 교체, 제거 가능.
- public일 필요가 없는 클래스의 접근 수준을 package-private 클래스로 좁혀라

#### 2. 멤버 접근 제한자

- private : 톱레벨 클래스에 접근
- package-private : 멤버가 소속된 패키지에서 접근
- protected : 상속받은 하위 클래스에서 접근
- public : 모든 곳에서 접근 가능
- 클래스의 공개 API를 살피고 **모든 멤버는 private**으로 선언하자
  - **필요한 곳만 package-private으로** 풀 것
- 테스트시에는 private 멤버를 **package-private** 까지 풀어주는 것은 괜찮다
- **public 클래스**의 인스턴스 필드는 되도록 **public이 아니어야 한다**.
  - public 가변 필드는 일반적으로 스레드 안전하지도 않다.
- **public static final** : 클래스가 표현하는 추상 개념 완성에 필요한 상수일 경우 괜찮다.

#### 3. 배열

- 배열 : 길이가 0이 아닌 배열은 모두 변경 가능하니 주의할 것
  - 따라서, 클래스에서 **public static final 배열 필드**를 두거나 이 필드를 반환하는 **접근 메서드를 제공해선 안된다.**

```java
public static final objects[] VALUES = {...};
```

**해결책**

1. 앞 코드의 public 배열을 private으로 만들고 **public 불변 리스트**를 추가

```java
private static final objects[] PRIVATE_VALUES = {...};
public static final List<objects> VALUES = 
    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

1. 배열을 private으로 만들고 그 **복사본을 반환하는 public 메서드** 추가

```java
private static final objects[] PRIVATE_VALUES = {...};
public static final objects[] values() { 
    return PRIVATE_VALUES.clone();
}
```





## Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- 객체지향에서는 **필드를 모두 private**으로 만들고 **접근자(setter)**를 추가한다.
- public 클래스는 **가변 필드를 노출해서는 안된다**.
- 접근자를 통해 내부 표현 방식을 바꿀수 있는 유연성이 있다.
- private라면 데이터 필드를 노출해도 문제가 없다.
- public 클래스의 final 변수 또한 노출 단점은 줄지만 좋지는 않다.





## Item 17. 변경 가능성을 최소화 하라

- **불변 클래스** : 인스턴스 **내부 값을 수정할 수 없는 클래스**
- 객체 파괴 순간까지 고정
- String, BigInteger...
- 불변 클래스는 가변 클래스 보다 설계, 구현, 사용이 쉬우며 **오류 확률이 적고 안전**하다.



### 불변 클래스 규칙

- 객체 **상태 변경 메서드를 제공하지 않는다**.
- **클래스를 확장할 수 없도록 한다**.(final 선언)
- 모든 **필드는 final**
- 모든 **필드는 private**
- 자신 외에 내부 가변 컴포넌트가 접근하지 못하게 한다.

```java
public final class Complex {
    private final real;
    private final imag;
    
    //constructor
    
    public Complex plus(Complex c) {
        return new Complex(real + c.real, imag + c.imag)
    }
    //methods...
}
```

- 메서드 또한 **새로운 인스턴스를 반환**하도록 한다.



### 장점

- 불변 객체는 생**성 시점의 상태를 파괴 순간 까지 유지**한다.
- 불변 객체는 근본적으로 **스레드 안전**하므로 따로 동기화 할 필요가 없다.
  - 안심하고 **공유가 가능**한다.
- 불변 객체는 자유롭게 공유할 수 있으며, 불변 객체끼리 내부 데이터를 공유할 수 있다.
- 객체를 만들 때 불변 객체를 구성요소로 사용하면 이점이 많다.
  - **집합**으로 사용할 수 있음
- 불변 객체는 그 자체로 **실패 원자성을 제공**한다.
  - 실패 원자성 : 예외 처리 이후에도 똑같은(유효한) 상태임을 보장



### 단점

- 값이 다르면 새로운 객체를 만들어야 한다.



### 불변 클래스 설계 방법

- **자기 자신을 상속하지 못하게 하라** : 생성자를 private으로 만들고 **public 정적 팩터리** 제공

```java
private Complex(...) {
    //...
}

public static Complex valueOf(double real, double imag) {
    return new Complex(real, imag)
}
```





## Item 18. 상속보다는 컴포지션을 사용하라

- 상속을 잘못 사용하면 오류를 내기 쉬운 소프트웨어가 된다
- 프로그래머가 조절할 수 있는 범위를 넘어 다른 패키지 클래스 상속은 위험하다.



- 상속은 캡슐화를 깨드린다.
- 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스 동작에 이상이 생길 수 있다.
- 문서화를 제대로 해두지 않으면 하위 클래스는 상위 클래스의 변경에 맞춰 또 다시 변경해줘야 한다.



### 해결 방법

#### 컴포지션 방법

- 클래스 확장 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조
- 새 클래스의 인스턴스에서 기존 클래스의 메서드를 호출하여 사용한다.
- 전달 방식이라고 하며, 새 클래스의 메서드를 전달 메서드라 한다.
- 기존 클래스의 변경에도 영향을 받지 않는다



### 상속 전 고려할 점

- 상속은 하위클래스가 진짜 하위 타입인 상황에서만 쓰여야 한다.
- is-a 관계 일때만 상속
- 확장하려는 API에 아무런 결함이 없는가?
- 결함이 클래스의 API까지 전파되도  괜찮은가?





### Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 상속용 클래스는 재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  - 재정의 가능 메서드라면 호출하는 메서드의 API 설명에 적시
  - 각각의 호출 결과 처리도 명시해야 함

- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 선별하여 protected 메서드 형태로 공개할 수도 있다.
- 상속용 클래스를 시험하는 방법은 직접 하위클래스를 만들어 실험해 보는 수밖에 없다.
- 상속용으로 설계한 클래스는 배포 전 반드시 하위클래스를 통해 검증해야 한다.
- 상속용 클래스 생성자는 재정의 가능 메서드를 호출하면 안된다.

```java
public class Super {
    public Super() {
    	overrideMethod();
    }
    
    public void overrideMethod() {...}
}
```

- 하위 클래스에서 메서드를 재정의 하면 오동작을 일으킬 수 있다.
- Cloneable과 Serializable중 하나라도 구현한 클래스를 상속하게 하는 것은 좋지 않다. 





## Item 20. 추상 클래스보다는 인터페이스를 우선하라

- 인터페이스도 디폴트 메서드를 제공할 수 있게 되었다.[java 8]
- 추상클래스와 다른 점은 추상클래스는 하위 클래스가 존재해야 한다는 것이다.



### 인터페이스의 장점

- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현할 수 있따.
  - 요구하는 메서드를 추가하기만 하면 끝
- 인터페이스는 믹스인 정의에 알맞는다.
  - 믹스인 : 클래스가 구현할 수 있는 타입. 구현한 클래스의 원래 주된 타입 외에 특정한 선택정 행위를 제공
  - 추상클래스는 기존 클래스에 덧씌울 수 없기 때문에 믹스인 정의가 불가
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.
- 래퍼 클래스를 통해 인터페이스 기능을 향상시키고 안전하게 사용할 수 있다.



### 추상 골격 구현

- 구현 방법이 명백한 것이 있다면 디폴트 메서드로 제공할 수 있다.
- 인터페이스로 타입 정의. 필요한 메서드는 디폴트 메서드로 제공
- 템플릿 메서드 패턴



- 관례적으로 인터페이스를 구현한 클래스 이름은 Abstract<인터페이스 명> 으로 짓는다.





## Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

- 디폴트 메서드를 선언하면 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모들클래스에서 **디폴트 구현이 사용**된다.
- 디폴트 메서드는 **구현 클래스를 고려하지 않고** 무작적 삽입 된다.
- 구현한 인터페이스의 **디폴트 메서드를 재정의** 하고, 다른 메서드에서 디폴트 메서드를 호출하기 전 필요한 작업을 수행하도록 한다.



- 디폴트 메서드는 기존 구현체에 **런타임 오류**를 일으킬 수 있따.
- 기존 인터페이스에 **디폴트 메서드로 새 메서드를 추가**하는 것은 꼭 필요한 경우가 아니라면 피해야 한다.
- 따라서 **인터페이스를 설계**할 때는 **세심한 주의**를 기울여야 한다.





## Item 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

- 인터페이스는 자신을 구현한 **클래스의 인스턴스를 참조할 수 있는 타입 역할**을 한다.
- 클래스가 **어떤 인터페이스를 구현**한다는 것은 자신의 **인스턴스로 무엇을 할 수 있는지 클라이언트에 얘기해 주는 것**이다.
  - 인터페이스는 오로지 이 용도로만 사용해야 한다.



- **상수 인터페이스** : 메서드 없이 static final 필드로만 구현된 인터페이스
  - 그러나 이것은 언터페이스를 잘못 사용한 예이다.
  - 상수는 내부 구현에 해당하고, 내부 구현을 API로 노출해선 안된다.





##  Item 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

- 두 가지 이상의 의미 중, 현재 표현하는 의미를 태그값으로 알려주는 클래스
- **태그 달린 클래스**의 단점
  - 열거타입, 태그필드, switch등 쓸데 없는 코드가 많다.
  - 메모리 많이 사용
  - 불필요한 초기화
- 태그 달린 클래스는 장황하고, 오류 내기 쉽고, 비효율 적이니 사용하지 말 것



### 태그 달린 클래스를 계층 구조로 바꾸는 방법

- 루트가 될 추상 클래스 정의
- 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언
- **동작이 일정한 메서드**들을 루트 클래스에 인발 메서드로 추가
- **공통 데이터**도 루트 클래스에 추가



- **계층구조**는 간단하고, 계층관계를 잘 표현하며, 유연성 또한 제공한다.





## Item 24. 멤버 클래스는 되도록 static으로 만들어라

- 중첩 클래스 : 다른 클래스 안에 정의된 클래스
  - e.g) Builder 클래스

- 중첩 클래스는 자신을 감싼 클래스에서만 쓰여야 한다.



### 중첩 클래스의 종류

#### 1. 정적 멤버 클래스

- **다른 클래스 안에 선언**되고, **바깥  클래스의 private 멤버에도 접근할 수 있다**는 점만 제외하고 일반 클래스와 같다.
- 다른 정적 멤버와 같은 접근 규칙
- public 도우미 클래스로 사용



#### 2. (비정적) 멤버 클래스

- 멤버 클래스의 인스턴스 메서드에서 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.
- 어댑터를 정의할 때 자주 쓰인다.
- 멤버 클래스에서 **바깥 인스턴스**에 접근할 일이 없다면 무조건 static을 붙여 정적 클래스로 만들자.

- **private 정적 멤버 클래스** : 바깥 클래스가 표현하는 객체의 한 부분을 나타낼 때 사용.



#### 3. 익명 클래스

- 이름이 없는 클래스
- 쓰이는 시점에 선언과 동시에 인스턴스가 생성된다.
- 지금은 람다로 대체



#### 4. 지역 클래스

- 지역변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언할 수 있고, scope도 지역변수와 같다.





## Item 25. 톱레벨 클래스는 한 파일에 하나만 담아라

- 소스파일 하나에 클래스를 여러개 선언하는 것은 위험하다.
- 어떤 것을 사용할지 컴파일러에 따라 달라진다.
  - 컴파일러에 어느 소스 파일을 먼저 건네느냐에 따라 동작이 달라진다.
- 톱 레벨 클래스들을 서로 다른 소스파일로 분리하라.




