# 4장 클래스와 인터페이스

- 자바 언어에는 클래스와 인터페이스 설계에 사용하는 요소가 있다
- 이런 요소를 활용하여 클래스와 인터페이스를 **쓰기 편하고, 견고하며, 유연하게** 만드는 방법



## Item 15. 클래스와 멤버의 접근 권한을 최소화하라

- 잘 설계된 컴포넌트 : 클래스 내부 데이터와 **구현 정보**를 외부로 부터 **얼마나 잘 숨겼느냐**
  - 내부 구현을 숨겨, **구현과 API를 깔끔히 분리**
- 오직 **API를 통해서만 소통**



### 정보 은닉의 장점

- 개발 속도 상승. 시스템 병렬개발 가능
- 시스템 관리 비용 감소. 컴포넌트 디버깅
- 성능 최적화에 도움
- 재사용성 증진
- 큰 시스템 제작 난이도 감소



### Java의 정보 은닉 장치

- 접근 제한자
- 기본 원칙 : 모든 클래스와 멤버의 **접근성을 가능한 좁힌다**.

#### 1. 클래스 접근 제한자

- public : 공개 API
- package-private : **패키지 안에서만 사용**. 내부 구현되어 언제든 수정 가능. 클라이언트에 영향 없이 수정, 교체, 제거 가능.
- public일 필요가 없는 클래스의 접근 수준을 package-private 클래스로 좁혀라

#### 2. 멤버 접근 제한자

- private : 톱레벨 클래스에 접근
- package-private : 멤버가 소속된 패키지에서 접근
- protected : 상속받은 하위 클래스에서 접근
- public : 모든 곳에서 접근 가능
- 클래스의 공개 API를 살피고 **모든 멤버는 private**으로 선언하자
  - **필요한 곳만 package-private으로** 풀 것
- 테스트시에는 private 멤버를 **package-private** 까지 풀어주는 것은 괜찮다
- **public 클래스**의 인스턴스 필드는 되도록 **public이 아니어야 한다**.
  - public 가변 필드는 일반적으로 스레드 안전하지도 않다.
- **public static final** : 클래스가 표현하는 추상 개념 완성에 필요한 상수일 경우 괜찮다.

#### 3. 배열

- 배열 : 길이가 0이 아닌 배열은 모두 변경 가능하니 주의할 것
  - 따라서, 클래스에서 **public static final 배열 필드**를 두거나 이 필드를 반환하는 **접근 메서드를 제공해선 안된다.**

```java
public static final objects[] VALUES = {...};
```

**해결책**

1. 앞 코드의 public 배열을 private으로 만들고 **public 불변 리스트**를 추가

```java
private static final objects[] PRIVATE_VALUES = {...};
public static final List<objects> VALUES = 
    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

1. 배열을 private으로 만들고 그 **복사본을 반환하는 public 메서드** 추가

```java
private static final objects[] PRIVATE_VALUES = {...};
public static final objects[] values() { 
    return PRIVATE_VALUES.clone();
}
```





## Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- 객체지향에서는 **필드를 모두 private**으로 만들고 **접근자(setter)**를 추가한다.
- public 클래스는 **가변 필드를 노출해서는 안된다**.
- 접근자를 통해 내부 표현 방식을 바꿀수 있는 유연성이 있다.
- private라면 데이터 필드를 노출해도 문제가 없다.
- public 클래스의 final 변수 또한 노출 단점은 줄지만 좋지는 않다.





## Item 17. 변경 가능성을 최소화 하라

- **불변 클래스** : 인스턴스 **내부 값을 수정할 수 없는 클래스**
- 객체 파괴 순간까지 고정
- String, BigInteger...
- 불변 클래스는 가변 클래스 보다 설계, 구현, 사용이 쉬우며 **오류 확률이 적고 안전**하다.



### 불변 클래스 규칙

- 객체 **상태 변경 메서드를 제공하지 않는다**.
- **클래스를 확장할 수 없도록 한다**.(final 선언)
- 모든 **필드는 final**
- 모든 **필드는 private**
- 자신 외에 내부 가변 컴포넌트가 접근하지 못하게 한다.

```java
public final class Complex {
    private final real;
    private final imag;
    
    //constructor
    
    public Complex plus(Complex c) {
        return new Complex(real + c.real, imag + c.imag)
    }
    //methods...
}
```

- 메서드 또한 **새로운 인스턴스를 반환**하도록 한다.



### 장점

- 불변 객체는 생**성 시점의 상태를 파괴 순간 까지 유지**한다.
- 불변 객체는 근본적으로 **스레드 안전**하므로 따로 동기화 할 필요가 없다.
  - 안심하고 **공유가 가능**한다.
- 불변 객체는 자유롭게 공유할 수 있으며, 불변 객체끼리 내부 데이터를 공유할 수 있다.
- 객체를 만들 때 불변 객체를 구성요소로 사용하면 이점이 많다.
  - **집합**으로 사용할 수 있음
- 불변 객체는 그 자체로 **실패 원자성을 제공**한다.
  - 실패 원자성 : 예외 처리 이후에도 똑같은(유효한) 상태임을 보장



### 단점

- 값이 다르면 새로운 객체를 만들어야 한다.



### 불변 클래스 설계 방법

- **자기 자신을 상속하지 못하게 하라** : 생성자를 private으로 만들고 **public 정적 팩터리** 제공

```java
private Complex(...) {
    //...
}

public static Complex valueOf(double real, double imag) {
    return new Complex(real, imag)
}
```





## Item 18. 상속보다는 컴포지션을 사용하라

- 상속을 잘못 사용하면 오류를 내기 쉬운 소프트웨어가 된다
- 프로그래머가 조절할 수 있는 범위를 넘어 다른 패키지 클래스 상속은 위험하다.



- 상속은 캡슐화를 깨드린다.
- 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스 동작에 이상이 생길 수 있다.
- 문서화를 제대로 해두지 않으면 하위 클래스는 상위 클래스의 변경에 맞춰 또 다시 변경해줘야 한다.



### 해결 방법

#### 컴포지션 방법

- 클래스 확장 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조
- 새 클래스의 인스턴스에서 기존 클래스의 메서드를 호출하여 사용한다.
- 전달 방식이라고 하며, 새 클래스의 메서드를 전달 메서드라 한다.
- 기존 클래스의 변경에도 영향을 받지 않는다



### 상속 전 고려할 점

- 상속은 하위클래스가 진짜 하위 타입인 상황에서만 쓰여야 한다.
- is-a 관계 일때만 상속
- 확장하려는 API에 아무런 결함이 없는가?
- 결함이 클래스의 API까지 전파되도  괜찮은가?





### Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 상속용 클래스는 재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  - 재정의 가능 메서드라면 호출하는 메서드의 API 설명에 적시
  - 각각의 호출 결과 처리도 명시해야 함

- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 선별하여 protected 메서드 형태로 공개할 수도 있다.
- 상속용 클래스를 시험하는 방법은 직접 하위클래스를 만들어 실험해 보는 수밖에 없다.
- 상속용으로 설계한 클래스는 배포 전 반드시 하위클래스를 통해 검증해야 한다.
- 상속용 클래스 생성자는 재정의 가능 메서드를 호출하면 안된다.

```java
public class Super {
    public Super() {
    	overrideMethod();
    }
    
    public void overrideMethod() {...}
}
```

- 하위 클래스에서 메서드를 재정의 하면 오동작을 일으킬 수 있다.
- Cloneable과 Serializable중 하나라도 구현한 클래스를 상속하게 하는 것은 좋지 않다. 





## Item 20. 추상 클래스보다는 인터페이스를 우선하라

- 인터페이스도 디폴트 메서드를 제공할 수 있게 되었다.[java 8]
- 추상클래스와 다른 점은 추상클래스는 하위 클래스가 존재해야 한다는 것이다.



### 인터페이스의 장점

- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현할 수 있따.
  - 요구하는 메서드를 추가하기만 하면 끝
- 인터페이스는 믹스인 정의에 알맞는다.
  - 믹스인 : 클래스가 구현할 수 있는 타입. 구현한 클래스의 원래 주된 타입 외에 특정한 선택정 행위를 제공
  - 추상클래스는 기존 클래스에 덧씌울 수 없기 때문에 믹스인 정의가 불가
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.
- 래퍼 클래스를 통해 인터페이스 기능을 향상시키고 안전하게 사용할 수 있다.



### 추상 골격 구현

- 구현 방법이 명백한 것이 있다면 디폴트 메서드로 제공할 수 있다.
- 인터페이스로 타입 정의. 필요한 메서드는 디폴트 메서드로 제공
- 템플릿 메서드 패턴



- 관례적으로 인터페이스를 구현한 클래스 이름은 Abstract<인터페이스 명> 으로 짓는다.


